# ICPC-Mangament Code Review

## 复杂度分析

记队伍总数 $N$，题目总数 $M$

两队之间的比较最坏可以达到 $O(M)$，但 $M$ 很小，我们不妨将它看作常数。

使用 unordered_map 将队名映射到一个 id, 因为是哈希，不妨认为 $O(1)$

- AddTeam   
  $O(\log N)$ 在 set 中插入队伍 id。

- Start  
  $O(NM)$ 需要给每个队伍每道题开空间。

- Flush  
  $O(N)$ 遍历一遍 set，更新 rank_of_team 

- Freeze  
  $O(NM)$ 给每个队伍每道题设置封榜标记。

- QueryRanking  
  $O(1)$ 直接从 rank_of_team 中对应查询

- Submit  
  $O(\log N)$ 在 set 中删除队伍，更新队伍数据后再插入。

- QuerySubmission  
  $O(1)$ 直接从 last_submit 中对应查询

- Scoreboard  
  $O(MN\log N)$ 每个队伍最多被遍历 M 次，每次操作 set 需要 $O(\log N)$ 

## 小结

本以为 2h 就可以写完了，结果写了 2h，调 bug 1h，卡常 1h。

第一次写这样大的工程代码，尽量把变量名函数名都写得很清楚了，自认为代码可读性还是不错的。

### 关于调 BUG
1. 以为把最后一个没解冻的队所有题按顺序解冻完，
2. 封榜后 AC 后的提交也记录提交次数
3. 少一个 `!` 惹的祸 `while (s.empty())` 

### 关于卡常

`cin`，`cout` 加速是个人都知道吧：

```cpp
std::ios::sync_with_stdio(false);
std::cout.tie(0);
std::cin.tie(0);
```

根据测试发现，常数瓶颈在于

1. 两队比较时，可能要遍历每到题，还要按照过题时间排序。
2. 滚榜时 `set` 的操作。

对于 (1)，原本的垃圾实现是每次在比较时把过题时间都捞出来，sort 一下在比较。改为记一个已过题时间数组，每次在过题时加入新的数据。

对于 (2)，考虑减少 `set.find(), set.erase(), set.insert()` 次数，如果排名不会有变化不必更新 set。使用 `set.insert(it, val)` ，以 `it` 作为 Hints 插入 `val` 常数会小一点。

当然目前的滚榜还可以优化，现在的写法是从后往前遍历榜单：
- 若当前队没有冻结题目，就跳过
- 若当前队有冻结题，则按顺序进行解冻：
  - 排名不变化，解冻下一题
  - 排名变化，更新 set，跳到他排名变化前下一队

这样每个没有冻结题的队都会被搜一次，每个有冻结题的队最多搜到其题数次。

想法是单独对需要解冻的队伍开一个 set，但是不想卡了，那样代码复杂度++。